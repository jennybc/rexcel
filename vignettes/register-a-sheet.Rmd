---
title: "Register an Excel Sheet"
author: "Jennifer Bryan"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Register an Excel Sheet}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, cache = FALSE}  
knitr::opts_chunk$set(error = TRUE)  
```

```{r}
library(rprojroot)
devtools::load_all(find_package_root_file())
```

A walk through the code in `rexcel_register()`. I wrote this function to make myself better acquainted with the files that make up an xlsx and with `rexcel`. It could evolve into something useful and/or some of this could be incorporated into `rexcel_read_workbook()` or `rexcel_read_worksheet()`.

Philosophy, at least in theory:

  * Don't error unless it's an invalid xlsx file. Try to do something useful, even if it's mostly informative messages about why something can't be read in.
  * Inner functions are typically of this form: `xlsx_read_*()`.
    * They always take `path` to xlsx as primary or only argument.
    - They read from exactly one file.
    - We have one to read every file that's there. *probably very untrue, in practice! since I create a manifest, I could actually check this ...*
  * Process data read from xlsx files only enough to create the minimal R object.
  * Inner functions always return a single object.
  * Why all of this? So it's easy to "drop in" on a problematic xlsx or to work on `rexcel`. I find it hard to do this when low-level functions work with lists that combine different objects and objects that come from different files. If you haven't run a bunch of other internal code first (or if some of that failed), it's hard to get into a good place for figuring out what's wrong.

### Example sheets

We illustrate different xlsx features using different example sheets. Pre-store their paths to make this easier.

```{r}
mini_gap_path <- system.file("sheets", "mini-gap.xlsx", package = "rexcel")
ff_path <- system.file("sheets", "gs-test-formula-formatting.xlsx",
                       package = "rexcel")
ek_path <- system.file("sheets", "Ekaterinburg_IP_9.xlsx", package = "rexcel")
ek2_path <- system.file("sheets", "Ekaterinburg_IP_9-RESAVED.xlsx",
                        package = "rexcel")
dn_path <- system.file("sheets", "defined-names.xlsx", package = "rexcel")
gabe_path <- system.file("sheets", "gabe.xlsx", package = "rexcel")
```

### Walk through `rexcel_register()`

`path` is path to the xlsx and is the only argument. We'll use different example sheets as we go. Let's start with mini Gapminder.

`is_xlsx()` runs sanity checks to make sure this looks like valid xlsx.

```{r}
is_xlsx(mini_gap_path)
```

### `manifest` = file list

`manifest` holds a list of files in the zip archive.

```{r}
manifest <- xlsx_list_files(mini_gap_path)
print(manifest, n = Inf)
```

Overview of manifests I've seen. *TO DO: cross-check/enhance this with some actual research in the spec or other resources we like.*

  * Workbook infrastructure
    - [Content_Types].xml
    - _rels/.rels *boring? I don't currently process*
    - xl/workbook.xml
    - xl/_rels/workbook.xml.rels
    - xl/sharedStrings.xml *doesn't necessarily exist*
    - xl/styles.xml
    - docProps/core.xml *have never looked at one of these; we have one in defined_names.xlsx*
    - docProps/app.xml *ditto*
  * Worksheet: one main file per sheet
    - xl/worksheets/sheet1.xml, xl/worksheets/sheet2.xml, ... is typical
    - but xl/worksheets/sheet.xml is also possible!
    - this is where sheet data actually lives, up to complications like the shared strings
  * Worksheet: a `rels` file for each sheet
    - xl/worksheets/_rels/sheet1.xml.rels and so on
  * Worksheet: a file of drawings?
    - xl/drawings/worksheetdrawing1.xml and so on
    - *you don't necessarily have these, but I see them even when there are no "drawings"*

The Ekaterinburg sheet from [readxl/#80](https://github.com/hadley/readxl/issues/80) has unusual structure. It was created by an undisclosed BI system but I include it here because the R packages that [wrap the Apache POI](https://poi.apache.org/spreadsheet/index.html) can read it just fine. So we should be able to return something informative for it.

Note the single sheet is referred to as `sheet`, not `sheet1`, and there is no associated `drawings` file.

```{r}
print(xlsx_list_files(ek_path), n = Inf)
```

If you open that workbook in Excel and resave it, things look different.

```{r}
print(xlsx_list_files(ek2_path), n = Inf)
```

We gain `docProps/app.xml`, `docProps/core.xml`, and `xl/theme/theme1.xml` and the single sheet is now referred to as `sheet1`, not just `sheet`. Still no drawings, though.

Conclusion: there is a lot of variety in the manifest for valid xlsx.

### [Content_Types].xml

The `ct` object created from `[Content_Types].xml` is a tibble associating content types with extensions or specific files:

  * two "general" rows for the extensions `.xml` and `.rels`
  * other rows for specific files seen in the manifest *I gather these override the general types associated with extensions?*

```{r}
(ct <- as.data.frame(xlsx_read_Content_Types(mini_gap_path)))
#setdiff(manifest$name, gsub("^\\/", "", ct$part_name))
#intersect(gsub("^\\/", "", ct$part_name), manifest$name)
```

### `sheets` info from xl/workbook.xml

Among many other things in `xl/workbook.xml`, there is one xml node per worksheet, which we use to make `sheets`. It's a tibble with one row per worksheet and these variables:

  * `name`: e.g., "Africa" *I assume this is name of the tab*
  * `state`: "visible" *or what else ... "invisible"?; might be `NA`*
  * `sheet_id`: integer *I assume this is order perceived by user*
  * `id`: character, e.g., `"rId5"` *a key that comes up elsewhere*

```{r}
(sheets <- xlsx_read_workbook_sheets(mini_gap_path))
```

Quick tour of similar info for other example sheets:

```{r}
xlsx_read_workbook_sheets(ff_path)
xlsx_read_workbook_sheets(ek_path)
xlsx_read_workbook_sheets(ek2_path)
xlsx_read_workbook_sheets(dn_path)
xlsx_read_workbook_sheets(gabe_path)
```

### Named ranges from xl/workbook.xml

Cell ranges can be named in Excel and subsequently used in formulas. These are described in `xl/workbook.xml` in the `definedName` nodes. Jenny has seen one node structure in the example she created, which differs from what Rich anticipated (presumably based on the spec?). Furthermore, Ekaterinburg has novel namespacing as well. See the comments in source for `xlsx_read_workbook_defined_names()` for details. Expect future pain here.

If a workbook has no named ranges, this will be `NULL`, e.g., as for mini Gapminder. Currently we have two example sheets with named ranges, `defined-names.xlsx` and `gabe.xlsx`. `defined-names.xlsx` was a planned example sheet. `gabe.xlsx` was intended just to explore weird worksheet names but, since it was copied from `defined-names.xlsx` and then worksheets got copied again, it incidentally shows what happens when there are replicated range names.

```{r}
xlsx_read_workbook_defined_names(mini_gap_path)
xlsx_read_workbook_defined_names(dn_path)
xlsx_read_workbook_defined_names(gabe_path)
```

`defined_names` is a tibble with one row per named range and these variables:

  * `name`: name of the named range
  * `refers_to`: string representation of the cell (area) reference, e.g., `Sheet1!$B$2:$B$11`
  * `sheet_id`: integer *I can't get my hands on a sheet that has actually this?*
  * `local_sheet_id`: integer *appears when names are replicated*

### Workbook rels from xl/_rels/workbook.xml.rels

*We should probably cook up a more interesting example here.*

Mini Gapminder is interesting because you see the sheets aren't numbered exactly as you'd expect (which is [`hadley/readxl#104`](https://github.com/hadley/readxl/issues/104)). Ekaterinburg is also interesting because `target` has a leading slash and includes the `xl` subdirectory. But the re-saved version looks more conventional.

```{r}
(workbook_rels <- xlsx_read_workbook_rels(mini_gap_path))
xlsx_read_workbook_rels(ek_path)
xlsx_read_workbook_rels(ek2_path)
```

`workbook_rels` is a tibble, each row a file, with variables

  * `target`: a file path relative to `xl/` *maybe I should prepend xl/?*
  * `id`: character, e.g., `"rId5"` *a key that occurs elsewhere*
  * `type`: a long namespace-y string, the last bit of which tells you
if the associated file is `sharedStrings`, styles, or a worksheet, e.g.,
`http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet`
*maybe I should retain just the last bit?*

### Derived object: `sheets_df`

We depart from the philosophy a bit here to create `sheets_df`, a new tibble with one row per worksheet. It joins `sheets`, which came from `workbook.xml`, to `workbook_rels`, which came from `workbook.xml.rels`. This is where we finally get sheet id, sheet name, id, and xml target file all in one place.

```{r}
(sheets_df <- join_sheets_workbook_rels(sheets, workbook_rels))
```

### Shared strings from xl/sharedStrings.xml

Strings do not appear in the main sheet data files but rather appear exactly once in `sharedStrings.xml` and are then referenced.

```{r}
(shared_strings <- xlsx_read_shared_strings(mini_gap_path))
```

`shared_strings` is a character vector, with attributes `count` (total # of strings?) and `uniqueCount` (its own length?).

Let's look at some others. **I have no idea what's going on with Ekaterinburg original vs re-saved!** Why do `count` and `uniqueCount` both blow up?

```{r}
xlsx_read_shared_strings(ff_path)
str(xlsx_read_shared_strings(ek_path))
str(xlsx_read_shared_strings(ek2_path))
xlsx_read_shared_strings(gabe_path)
```

### Styles from xl/styles.xml

Where to begin? I got as far as parsing the fonts. Then decided this, more anything else, was a ridiculous thing to re-do. Rich has made a great start on it. Revisit on a strict as needed basis.

```{r}
(styles <- xlsx_read_style(mini_gap_path))
```

`styles` is a list of `tbl_df`s:

  * fonts: Variables include `name`, `color`, `sz`.
  * fills: Variables include `pattern_type` and `fg`.
  * borders: Variables include `outline` and `top_color`.
  * num_fmts: Variables are `num_format_id` and `format_code`, where the format codes are those things familiar from Excel, such as `"$"#,##0.00`.
  * *stuff below here seems to index into / synthesize the above?*
  * cell_style_xfs: tibble of cell styles? Variables include `border_id`, `fill_id`, `font_id`, `num_fmt_id` (see above), `shrink_to_fit`, `text_wrap`.
  * cell_xfs: *what is this? seems to have same variables as cell_style_xfs. But for mini gapminder, this has 2 rows, whereas cell_style_xfs has only one.*
  * cell_styles: tibble of cell styles? Variables include `builtin_id`, `name`, `xf_id`.
  * *Here's a mystery node from mini gapminder style xml: `<dxfs count="0"/>`. What is that even? This is a typical value (it is missing from Ekaterinburg). This node has much more content in the formulas and formatting sheet. Discuss with Rich.*

Again, Ekaterinburg has different namespace for the XML in `styles.xml`. I learned this in my now-abandoned effort to look into the styles myself (I got as far as fonts):

  * Typical xlsx has a default namespace for the styles XML.
  * But Ekaterinburg uses the same (I think?) namespace, `http://schemas.openxmlformats.org/spreadsheetml/2006/main`, but with prefix `x`. So that would need to be finessed to read styles out of such sheets.

Let's try to read other styles.

```{r}
xlsx_read_style(ff_path)
## as explained above, namespace crazy means this won't work
#xlsx_read_style(ek_path)
xlsx_read_style(ek2_path)
xlsx_read_style(dn_path)
xlsx_read_style(gabe_path)
```

### Worksheet rels from xl/worksheets/_rels/sheet[0-9]*.xml.rels

There is up to one file per worksheet in `xl/worksheets/_rels/`. From these we make the tibble `worksheet_rels`, where each row corresponds to the file for a worksheet. It is possible for a worksheet to have no associated `rels` file and it is possible for a workbook to have zero worksheet `rels` files, in which case this object will be `NULL`.

When this tibble exists, here are the variables:

  * worksheet: character, e.g. "sheet1". Note: I created this from filename.
  * id: character, so far typically it's "rId1", except for Ekaterinburg, of course
  * type: uniformly a long name-spacey string ending in "drawing" or "hyperlink"
  * target: how to get to the thing. So this could be a relative local path to the "drawing" file. Or it could be a URL.
  * targetmode: "External" when target is a URL, otherwise seems to not exist or be `NA`

Let's just look at these worksheet rels for all of our examples.

```{r}
as.data.frame(worksheet_rels <- xlsx_read_worksheet_rels(mini_gap_path))
as.data.frame(xlsx_read_worksheet_rels(ff_path))
as.data.frame(xlsx_read_worksheet_rels(ek_path))
as.data.frame(xlsx_read_worksheet_rels(ek2_path))
as.data.frame(xlsx_read_worksheet_rels(dn_path))
as.data.frame(xlsx_read_worksheet_rels(gabe_path))
```

### Drawings such as xl/drawings/worksheetdrawing1.xml

I am not dealing with this. But want to record that it is typical to see one of these files per worksheet, even where there are no "drawings", e.g., plots. Case in point: mini Gapminder.

```{r}
subset(xlsx_list_files(mini_gap_path), grepl("drawing", name))
```

### High-level info from worksheets

OMG we have finally arrived here! I'm coming back to this soon!

### Putting it all together

All of the above is bundled together in the function `rexcel_register()`, which currently returns a list with the assembled components.

```{r}
mini_gap_workbook <- rexcel_register(mini_gap_path)
str(mini_gap_workbook, max.level = 1)
mini_gap_workbook
```

Let's review the components:

  * `xlsx_path`: path to the xlsx
  * `reg_time`: time xlsx was processed
  * `manifest`: file list for the xlsx zip archive
  * `content_types`: tbl representing `[Content_Types].xml`
  * `sheets`: tbl representing `xl/workbook.xml`
  * `defined_names`: tbl for named ranges
  * `workbook_rels`: tbl representing `xl/_rels/workbook.xml.rels`
    - links target files to `id`s, also gives file type
    - example: tells you that `id = rId4` refers to `Target` file `xl/worksheets/sheetX.xml`
  * `shared_strings`: character vector representing `xl/sharedStrings.xml`
  * `styles`: list of tbls from `xl/styles.xml`
  * `worksheet_rels`: tbl about files or external resources (URLs) that relate to the worksheets. Comes from files like `xl/worksheets/_rels/(sheet[0-9]+).xml.rels`.
  * `sheets_df`:
    - This is arguably the only thing I created.
    - A tbl with one row per worksheet, from joining `sheets` and `workbook_rels`

### Relating this to `rexcel_read_workbook()`

Looking at the innards of `rexcel_read_workboobk()` to compare and contrast.

```{r}
path <- mini_gap_path

dat <- xlsx_read_workbook(path)
str(dat, max.level = 1)
dat$rels
dat$sheets
dat$defined_names

## let's look at defined names in a sheet that actually has them
xlsx_read_workbook(dn_path)$defined_names
```

`dat$rels` is what I call `workbook_rels`.

`dat$sheets` is almost equivalent to my `sheets_df`.

`dat$defined_names` should be equivalent to my `defined_names`, but Rich did not anticipate the structure of the nodes I am seeing.

```{r}
(strings <- xlsx_read_shared_strings(path))
(date_offset <- xlsx_date_offset(path))
```

`strings` is my `shared_strings`.

I don't have anything like `date_offset`. Should I?

```{r}
style_xlsx <- xlsx_read_style(path)
str(style_xlsx, max.level = 1)
(lookup <- tibble::data_frame(
  font    = style_xlsx$cell_xfs$font_id,
  fill    = style_xlsx$cell_xfs$fill_id,
  border  = style_xlsx$cell_xfs$border_id,
  num_fmt = style_xlsx$cell_xfs$num_fmt_id))
```

Interesting. I hadn't absorbed that the font, fill, border, and num_fmt tibbles were synced up like this. Good to know. I should proactively check this when I run `xlsx_read_workbook()` sheets on all the examples systematically.

What are the implications of this? What is the point of `lookup`? Should we make some giant hairy monster tibble for formatting that has rows like the rows of `lookup` but cbinds the formatting info from the different domains?

```{r}
## numeric formatting
n <- max(style_xlsx$num_fmts$num_format_id)
fmt <- rep(NA_character_, n)
fmt[seq_along(xlsx_format_codes())] <- xlsx_format_codes()
fmt[style_xlsx$num_fmts$num_format_id] <- style_xlsx$num_fmts$format_code
num_fmt <- tibble::data_frame(num_fmt = fmt)
style <- linen::linen_style(lookup, font = style_xlsx$fonts,
                            fill = style_xlsx$fills,
                            border = style_xlsx$borders,
                            num_fmt = num_fmt)

(workbook <- linen::workbook(sheets, style, dat$defined_names))

sheets <- 1L
(sheets <- xlsx_sheet_names(dat)[sheets])
```

Objective 2: Visit and extract information for all requested worksheets.

In this case, I'm just reading the first and only sheet. This loop appears in `rexcel_read_workbook()` and calls `rexcel_read_worksheet()` for each requested worksheet. This is the loop and function we eventually exit from and this `workbook` object is what's returned.

```{r}
## enter rexcel_read_worksheet()
## rexcel_read_worksheet(path, s, workbook, dat, strings, style, date_offset)
(sheet <- sheets[1])
(sheet_idx <- match(sheet, workbook$names))
(sheet_name <- sheet)

(target <- xlsx_internal_sheet_name(sheet, dat))
(rels <- xlsx_read_rels(path, target))
```

Now we drop down into a lower-level non-exported function, `xlsx_read_sheet()`.

```{r}
## enter xlsx_read_sheet()
(file <- xlsx_internal_sheet_name(sheet_idx, dat))
xml <- xlsx_read_file(path, file) ## at last! the xml! w00t!
(ns <- xml2::xml_ns(xml)) ## much less w00t now :(

(merged <- xlsx_read_merged(xml, ns))
(view <- xlsx_ct_worksheet_views(xml, ns))
(cols <- xlsx_ct_cols(xml, ns)) # NOTE: not used yet

## this is where it's at!
(cell_dat <- xlsx_parse_cells(xml, ns, strings, style, date_offset))

## not even sure what this is
(rows <- cell_dat$rows)

## this is where cells come from  
(cells <- linen::cells(cell_dat$cells$ref, cell_dat$cells$style,
                       cell_dat$cells$type, cell_dat$cells$value,
                       cell_dat$cells$formula))

## in real life and in other sheets, it's possible comments will be populated
## but not in this sheet
comments <- NULL
```

Now we gather everything we've learned about this worksheet into a `linen::worksheet` object.

```{r}
(ws <- linen::worksheet(sheet_name, cols, rows, cells, merged, view, comments,
                        workbook))
```

If we had other sheets to read, that would be done now. Ultimately this `workbook` is returned.
